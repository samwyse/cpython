PEP: 9999
Title: Register Virtual Machine for Python
Author: Skip Montanaro <skip@python.org>
Status: Active
Type: Standards Track
Content-Type: text/x-rst
Created: 18-Mar-2021
Python-Version: 4.0
Post-History: dd-mmm-yyyy

.. Process with rstpep2html to get table of contents and preserve
   above header.

Abstract
========

This PEP proposes the addition of register-based instructions to the
existing Python virtual machine, with the intent that they eventually
replace the existing stack-based opcodes.  Though both sets of
instructions are active in this effort, that is largely to make
initial testing easier.  They are almost completely distinct.  Within
a single function only one set of opcodes or the other will be used at
any one time.  (A few instructions are used by both.)  Considering
that, the current stack-based opcodes are referred to below as the
Python Virtual Machine ("PyVM") and the new register-based opcodes are
referred to as the Register Virtual Machine ("RVM").

Though submitted as a standards track PEP, the approach taken in the
initial implementation requires PyVM to be active as RVM is developed.
For that reason, as of its initial writing this document serves as
much as a guide for the architecture changes and for work which must
be done as for a rationale for the new virtual machine.


Motivation
==========

Stacks vs. Registers
--------------------

Most high-level languages have traditionally been implemented with
stack-based virtual machines.  Implementing a virtual machine
increases portability of the language.  Implementing the virtual
machine as a stack VM simplifies the implementation, at least
initially.  Instead of managing the lifetimes of data in a potentially
large register file, all the implementation has to worry about is the
top few elements of the stack, managing a single stack pointer. Still,
despite the management overhead and larger code size, research shows
that the performance of register VMs can be significantly better than
stack VMs ([#vmshowdown]_).  The authors showed a greater than 25%
performance improvement of a register VM even when threaded dispatch
was implemented for the stack VM.

Cribbing an example from [#winterbottom]_, consider the memory
activity of a simple ADD operation. To implement the simple C or Java
statement ``c = a + b;`` in a stack VM, we execute a series of
instructions like this::

    push a    # LS
    push b    # LS
    add       # LLS
    store c   # LS

where in the comments, "L" indicates a load into the virtual machine
and "S" a store.  So, to implement the ``push a`` instruction, the
value associated with the name ``a`` is loaded into the virtual
machine, then pushed onto the stack (we assume the stack is
implemented in memory).  The result is four instruction dispatches,
five loads, four stores and one add.  Contrast that with the execution
of an add operation in a three-address register machine::

    add a,b,c   # LLS

We load ``a`` and ``b`` into the virtual machine, perform the add,
then store the result into the memory location associated with ``c``.
The result is one instruction dispatch, two loads, one add and one
store.  While the add instruction is going to be larger in the
register VM (it must specify all operands), the total amount of work
done (instruction fetch and decode, movement between memory and the
machine) is significantly reduced.

We are mixing metaphors here a bit, as a virtual machine has no
silicon, so the concept of a "register" is really just a location in
memory.  Still, the extra data movement in the stack VM is real.

Python's Stack Machine
----------------------

Over the past two decades, Python's virtual machine has been improved
in many ways.  Among the most visible to the core Python developer
are:

- Peephole optimizations [#peephett]_

- Function call performance improvements [#pep-590]_

- Use of computed gotos and opcode prediction [#predpitr]_

- Introduction of many new instructions (reference?)

- Wordcode [#wordcode]_

Despite all that effort, opcodes which do nothing more than move data
onto or off of the stack (``LOAD_FAST``, ``LOAD_GLOBAL``, etc) still
account for nearly half of all opcodes executed.  This has been
consistently true over a long period of time [#dynlemb]_, [#instpage]_
and remains true today.  Running Pyperformance using a development
version of Python 3.9 showed that the five most frequently executed
pure stack opcodes (``LOAD_FAST``, ``STORE_FAST``, ``POP_TOP``,
``DUP_TOP`` and ``ROT_TWO``) accounted for 35% of all executed
instructions.  They are low-cost instructions (compared with
``CALL_FUNCTION`` for example), but still eat up time and space in the
virtual machine, making it less efficient than it might be.  (The
pcomplete table of opcode frequencies is in `Appendix - Opcode
Frequencies`_.)

Consider the layout of the data section of a Frame object::

    +----------------+-----------------+------------+
    |                |                 |            |
    | fastlocals     | cells + frees   | stack      |
    +----------------+-----------------+------------+
    ^                ^                 ^
    |                |                 |
    +-- f_localsplus +-- f_cellvars    +-- f_valuestack

All those ``LOAD_FAST`` and ``STORE_FAST`` instructions just copy
pointers between chunks of RAM which are separated by just a few bytes
of memory.  It seems reasonable to consider a different layout where
``fastlocals`` and the ``stack`` (reimagined as temporary registers)
are adjacent and, taken together, could be reimagined as an
addressable register file::

    +---------------------------+----------------+
    |                           |                |
    | fastlocals + registers    | cells + frees  |
    +---------------------------+----------------+
    ^                           ^
    |                           |
    +-- f_localsplus            +-- f_cellvars

While swapping out the virtual machine in toto doesn't qualify as "low
hanging fruit," even after all this time it seems like it might
worthwhile to investigate such a change.


Previous Work in Python
=======================

A number of previous systems implemented register virtual machines
aimed (at least in part) at Python. Both Rattlesnake and Victor
Stinner's systems described below were aimed only at Python and
translated PyVM to their respective register virtual machines. Both
were also based on the old variable length bytecode instruction
format.  In 2005, Jeremy Hylton merged a new AST-based compiler to the
master development branch [#asthylt]_. This was not available in the
Rattlesnake era.


Rattlesnake
-----------

Between 1998 and 2001, the author began work on a system named
Rattlesnake based on Python 1.5.2.  It was never more than a barebones
proof-of-concept, but did implement over 50 register-oriented
instructions, a substantial fraction of the machine at that time.  Its
structure was based on an earlier peephole optimizer written by the
author [#peepmont]_ and implemented as a peephole optimization class
which could be chained together with other optimizations.  As such, it
worked from the existing PyVM instructions, not any higher-level
representation.  While it never saw the light of day, the code
followed the author of this document around from one computer to
another (somehow never getting lost) and remained a persistent
reminder of the possibility it represented.  It lives on, providing
much of the conceptual framework for the current project.

Victor Stinner
--------------

In 2012, Victor Stinner implemented a nearly complete system
[#regstin].  Though noy incorporated into the Python codebase, it
demonstrated a significant performance improvement and was very close
to a complete system.

Parrot
------

Parrot [#parrot]_ is/was an ambitious project which aimed to be a
common register-based virtual machine backend for a number of
different languages, initially Python and Perl 6 (now known as Raku
[#raku]_).  Python support was supposed to be mediated through a
project called Pynie [#pynie]_ (or later, Puffin [#puffin]_), but all
components except for Raku seem incomplete/dormant.  Raku is a
language specification. Rakudo seems to be the most complete
implementation.  Its compiler has three backends, JVM, JavaScript and
MoarVM [#moar]_.


Basic Example
=============

Consider the following trivial function::

    def foo(a,b):
        return a+b

Python's bytecode compiler generates the following code for the
function body::

     0 LOAD_FAST                0 (a)
     2 LOAD_FAST                1 (b)
     4 BINARY_ADD
     6 RETURN_VALUE

The first two instructions copy the values associated with the local
variables a and b to the top-of-stack so the ``BINARY_ADD`` opcode can
operate on them.  The result of the add operation replaces the two
values at the top-of-stack with the sum.  The ``RETURN_VALUE`` opcode
then returns that value to the caller.  Note that the memory locations
of ``a`` and ``b`` and the stack are only a few bytes apart, making
the extra data movement all that much more frustrating. Why not
operate on them in place?

The register virtual machine (RVM) changes that.  It converts PyVM
opcodes to a new three-address virtual machine.  In its initial form,
it generates code very similar to the existing compiler for the above
function::

     0 EXTENDED_ARG         2
     2 LOAD_FAST_REG      512
     4 EXTENDED_ARG         3
     6 LOAD_FAST_REG      769
     8 EXTENDED_ARG         2
    10 EXTENDED_ARG       514
    12 BINARY_ADD_REG  131587
    14 RETURN_VALUE_REG     2

That's a bit difficult to read, so I will decode the arguments to the
load, add and return opcodes::

     0 EXTENDED_ARG                 2
     2 LOAD_FAST_REG           %r2, a
     4 EXTENDED_ARG                 3
     6 LOAD_FAST_REG           %r3, b
     8 EXTENDED_ARG                 2
    10 EXTENDED_ARG               514
    12 BINARY_ADD_REG   %r2, %r2, %r3
    14 RETURN_VALUE_REG           %r2

The ``LOAD_FAST_REG`` opcode works just like the current ``LOAD_FAST``
opcode but copies the values to a register instead of the top-of-stack
(though as should be apparent the difference between a "register" and
the "stack" is only semantic).  The ``BINARY_ADD_REG`` opcode adds the
contents of registers ``%r2`` and ``%r3`` and places the result back
into ``%r2``.  (For three-address instructions, the operand order is
dst, src1, src2).  Finally, the ``RETURN_VALUE_REG`` opcode returns
the value in ``%r2``.

This doesn't seem any more efficient than the current VM instructions,
and in fact, it isn't.  In addition, it uses more memory than the
stack version (14 bytes vs 6) because registers must be explicitly
addressed.  However, RVM takes advantage of an interesting property of
Python frame objects, namely that the space allocated for local
variables and the stack space are adjacent (or nearly so)::

    typedef struct _frame {
        PyObject_HEAD
        ...
        PyObject **f_valuestack;   /* points after the last local */
        ...
        int f_nlocals;             /* number of locals */
        int f_stacksize;           /* size of value stack */
        PyObject *f_localsplus[1]; /* locals+stack, dynamically sized */
    } PyFrameObject;

The _frame declaration was extracted from the 1.5.2 frame object
struct definition.  Python 3.9, the current base version for
Rattlesnake, is slightly different, but we can still make the local
variables and stack/register adjacent.)

If we treat the local variable array and the temporary operand stack
as a contiguous array, in many instances we can operate on the values
they contain without first copying values onto the stack.  In fact, we
will consider the variables a and b to reside in registers ``%r0`` and
``%r1``.  We can thus optimize out the load operations.  First, we
propagate ``a`` and ``b`` through the code where we read ``%r2`` and
``%r3``.  (In what follows, I elide the ``EXTENDED_ARG`` opcodes, but
they are really still there where required.)::

     2 LOAD_FAST_REG      %r2, a
     6 LOAD_FAST_REG      %r3, b
    12 BINARY_ADD_REG     %r2, a, b
    14 RETURN_VALUE_REG   %r2

Note that we only propagate references to ``a`` until some other
opcode overwrites ``%r2``.  Accordingly, we don't replace ``%r2`` with
a in either the ``BINARY_ADD_REG`` or ``RETURN_VALUE_REG`` opcodes.

Since ``%r2`` and ``%r3`` are no longer used as source operands before
``%r2`` is written by ``BINARY_ADD_REG``, the load ops which populated
them are no longer necessary and can be deleted::

    12 BAR      %r2, a, b
    14 RVR      %r2

The end result is a reduced instruction count, less memory usage, and a
faster virtual machine.


Implementation
==============

The "correct" approach would be to generate RVM instructions directly
from the AST.  Alas, the author had no experience with it and decided
to fall back to naive bytecode translation from PyVM to RVM with later
optimization.  That provides fewer optimization opportunities
initially, but allows all the translation to be done using a separate
Python module.  It should provide enough data to decide if the general
idea is workable.  Aside from allowing quicker experimentation, it
also makes the development more accessible to Python developers
without much experience with the CPython implementation.  If the
approach proves worthwhile, developers with more experience in the
current Python internals can push that part of the system forward.
Consider the current approach an attempt at producing a "minimum
viable product," to use a business buzz phrase.

Obviously, some work in the C code base is required.  This is mostly
confined to two files:

- ``Python/ceval.c`` - Each new instruction must be implemented, but
  Python/ceval.c provides an excellent set of templates in the form of
  the current PyVM instructions.  For the most part, the semantics of
  an RVM instruction are the same as the corresponding PyVM
  instruction.  The main difference between pairs of related
  instructions is how they fetch their data and store their results.

- ``Objects/frameobject.c`` - Most of this work has been done already,
  but more could be done.  The primary work necessary was
  reorganization of the ``f_localsplus`` array so local variables and
  the PyVM stack space were adjacent.  As Stinner noted though
  [#regstin]_, adding a copy of the code object's constants to the
  frame object is also a performance win.  This is suggested by the
  opcode frequencies table.  ``LOAD_CONST`` is the second most
  frequently executed instruction.


Reference Counts
----------------

While the same memory is used for the stack (PyVM) and registers
(RVM), their semantics are different.  When used as a stack, that
memory is completely transparent to reference counts.  As objects are
pushed on and popped from the stack, the responsibility of maintaining
reference counts lies with the individual instructions.  At the end of
normal function execution, the stack will have dwindled away to
nothing, meaning no reference counts need to be decremented.

Such is not the case when that memory is used for registers.  At the
end of function execution, any number of them might still be active
and require decrement of their reference counts.  In the current
implementation, this happens at the end of
``_PyEval_EvalFrameDefault``.  Since the pattern of use of the
register space can differ from one call of a function to the next and
frame objects are reused where possible, the registers are cleared
using ``Py_CLEAR`` (effectively ``Py_XDECREF`` followed by zeroing out
the memory location), not just ``Py_XDECREF``'d.


Object Lifetime
'''''''''''''''

Closely related to reference counts is the notion of object lifetime.
When an object's reference count drops to zero, CPython's semantics
mean it will be reclaimed immediately.  What happens if an object is
created and completely used early during the execution of a
long-running function but its reference count doesn't drop to zero
until the end of the function?  Consider this (silly) function::

    def long_running():
        x = [1] * int(10e7)
        y = [2] * int(10e7)
        z = (x + y) * 3
        char = z[99]
        result = do_something_long_running(char)
        return result

In PyVM, the memory for ``x`` and ``y`` would be reclaimed after being
added together. RVM currently only reclaims them at the end of the
function, when the reference counts of all registers are
``Py_XDECREF``'d.  This will need to change.

Currently, RVM clears registers at the end of frame execution.
Instead, registers should be cleared upon last reference.  All three
large lists currently stick around until function return, but are
unused after extracting the single character which is used.  For that
length of time, a large amount of memory is consumed unnecessarily.
The comments above indicate where registers holding x, y and z should
be cleared.  Victor Stinner's implementation [#regstin] does this
correctly.


Backwards Compatibility
=======================

Since the instruction set is an internal implementation detail
(although a significant one), there should be few backward
compatibility issues.  (Note the object lifetime discussion above,
however.) Tools which manipulate bytecode will obviously have to be
modified.  The ``dis`` module has been modified as necessary and will
probably undergo further changes.


Reference Implementation
========================

An in-progress (not yet complete) implementation [#regmont]_ is
available as a fork of the current CPython GitHub repo.  As of this
writing (March 2021) it remains quite incomplete, implementing just 57
register instructions compared with the 120+ PyVM instructions. (Note
though that some PyVM instructions should disappear, including stack
rotation instructions and --- with optimizations --- many register
loads and stores.


Current Status
--------------

As of March 18, 2021:

- Implemented more than 50 instructions (the easy ones <wink>) - all
  ``BINARY``, ``INPLACE`` and , ``UNARY`` instructions,
  ``RETURN_VALUE_REG``, most ``LOAD`` instructions, several ``STORE``
  instructions, ``COMPARE_OP_REG``, ``JUMP_IF_(TRUE|FALSE)_REG``, some
  ``CALL_FUNCTION`` instructions, most container-related ``BUILD``
  instructions, ``LIST_EXTEND_REG``, some loop and iteration
  instructions and dictionary merge/update. Simple test cases exist
  for most of these, though the most recently added instructions
  probably still lack suitable test cases. (When the 'make test'
  target completes, it identifies implemented instructions which
  weren't executed on the run.)

- Implemented translator parts

  - Identification of basic blocks

  - Mapping between the PyVM and RVM versions of the above
    instructions (much leftover from Rattlesnake, but not yet tested)

  - Elimination of ``LOAD_FAST_REG`` and ``STORE_FAST_REG`` by forward
    propagation of the former. Implementation of backward propagation
    to eliminate the latter was broken, so is currently disabled.
    There is still work to do here, but it represents a good place for
    optimization.  Note

  - Generation of wordcode from the RVM blocks.

  - At one point, based on current testing, using -R with
    ``Tools/scripts/run_tests.py``, reference counting seemed to
    work.  That seems not to be the case at the moment.


Implementing More Instructions
''''''''''''''''''''''''''''''

Initially, most instructions could be revealed in isolation with a
simple function, making it fairly easy to implement and test the
translations.  Plenty of instructions remain which can be implemented
in isolation, most of which should have straightforward
implementations.  For example (not exhaustive)::

    BUILD_SLICE
    BUILD_STRING
    CALL_METHOD
    DELETE_GLOBAL
    DELETE_SUBSCR
    FORMAT_VALUE
    IMPORT_FROM
    LOAD_DEREF
    LOAD_METHOD
    STORE_SUBSCR
    YIELD_FROM
    YIELD_VALUE

Some instructions (``DUP_TOP``, ``ROT`` instructions, ``POP_TOP``,
etc) may not require translation at all, and just require a little bit
of extra bookkeeping during translation.

Still, as more complex control flow constructs are tackled, larger
groups of not-as-yet-translated instructions must be implemented.  It
would be worthwhile to try and translate as many of the necessary
instructions in more-or-less isolation to reduce the number of
translations which must be implemented correctly before any testing
can proceed.  Here are some example functions and the instructions
they use which have not yet been translated.

This function::

    def f(a):
      try:
        return 17.1 / a
      except ZeroDivisionError:
        print("a is zero!")
        raise

requires::

    DUP_TOP
    JUMP_IF_NOT_EXC_MATCH
    POP_BLOCK
    POP_EXCEPT
    POP_TOP
    RAISE_VARARGS
    RERAISE
    SETUP_FINALLY

This function::

    def f(a):
      for i in range(a):
        yield i

requires::

    POP_TOP
    YIELD_VALUE

Async functions are especially complex.  This function::

    async def f():
        print('hello')
        await asyncio.sleep(1)
        print('world')

requires::

    CALL_METHOD
    GET_AWAITABLE
    LOAD_METHOD
    POP_TOP
    YIELD_FROM

This function::

    async def f(a):
      async for i in range(a):
        pass

requires::

    GET_AITER
    SETUP_FINALLY
    GET_ANEXT
    YIELD_FROM
    POP_BLOCK
    END_ASYNC_FOR

This function::

    async def f(fn):
      async with open(fn) as fp:
        return fp.read(1)

requires::

    BEFORE_ASYNC_WITH
    CALL_METHOD
    DUP_TOP
    GET_AWAITABLE
    LOAD_METHOD
    POP_BLOCK
    POP_EXCEPT
    POP_TOP
    RERAISE
    ROT_TWO
    SETUP_ASYNC_WITH
    WITH_EXCEPT_START
    YIELD_FROM

This function::

    def f(fn):
      with open(fn) as fp:
        print(fp.read(1))

requires::

    CALL_METHOD
    DUP_TOP
    POP_BLOCK
    POP_EXCEPT
    POP_TOP
    RERAISE
    SETUP_WITH
    WITH_EXCEPT_START

To simplify implementation of these more complex translations, picking
off as many of the unimplemented simpler translations first would be
worthwhile.


Rejected Ideas
==============

No ideas have truly been rejected at this point.  The author has
simply been following the path of least resistance.  That means
implementing bits in Python where possible and disturbing the rest of
the CPython implementation as little as possible.  Those are just
trade-offs necessary to move things forward.  They aren't cast in
stone.  For expedience, a number of changes weren't undertaken.  For
example, to minimize compatibility problems between PyVM and RVM,
wordcode has so far been retained.


Open Issues
===========

A large number of issues remain unresolved.  See the `issue
tracker <https://github.com/smontanaro/cpython/issues>`_ for a number
of open issues not included here.

- This proto-PEP - It is still quite incomplete, and really hasn't
  been tracking the implementation very well in the past several
  months.

- Wordcode - To simplify the work, wordcode was retained.  This works,
  but relies heavily on the ``EXTENDED_ARG`` mini-instruction to
  provide arguments to instructions which need more than one.  At the
  moment, ``COMPARE_OP_REG`` is the argument champ, requiring four
  args.  While ``EXTENDED_ARG`` is really only half an instruction,
  most RVM instructions implemented so far must be prefixed by at
  least one of them.  It would be worth considering if a 32-bit
  instruction size for RVM makes more sense, both as a performance
  improvement and to reduce the size of the generated code.  (medium)

- Implement opcode prediction/fast dispatch.  Without that, you can't
  make apples-to-apples performance comparisons.  (easy?)

- Translation of larger compilation units than functions (classes,
  modules and packages) with output to a bytecode file (perhaps with
  ".pyr" extension).  (medium?)

- Refactor InstructionSetConverter - This still contains remnants of
  the original peephole optimizer.  The base class is likely no longer
  required, and ISC itself could probably be split into multiple mixin
  classes.  (easy)

- Rework dis module or instruction names - Tacking on ``_REG`` to a
  bunch of instructions threw off the dis module's (fragile) output
  formatting.  Increasing ``dis._OPNAME_WIDTH`` from 20 to 23 and
  reformatting **every expected output string** in ``test_dis.py``
  helped for awhile until even longer instruction names arrived.  All
  that reformatting was tedious.  Fixing ``dis`` to be more resilient
  might be a better way to go.

  OTOH, maybe RVM opcode names should look more like traditional
  assembler instructions.  (The author is getting on in years and
  finds something which looks more like assembler attractive, given
  his initial experience programming computers in the dark ages.)
  Instead of ``BINARY_ADD_REG``, you might call it ``BAR``.  Simply
  constructing opcode names by joining the first letters of each word
  won't work though (collisions - ``BINARY_ADD_REG`` and
  ``BINARY_AND_REG`` would both map to ``BAR``), so you'd have to
  implement a scheme which overrides in specific instances (``BAR``
  and ``BANDR``, for example).  (easy?)

- Matrix multiplication is so far untested, mostly because I can't
  handle classes yet.

- API separating generator object implementation from stack VM.
  Currently, ``Objects/genobject.c`` manipulates the current virtual
  machine stack directly.

Files
=====

These are the big changes.

- Lib/rattlesnake - The Python implementation of the translator

- Lib/opcode.py - Enumeration of the implemented opcodes

- Python/ceval_reg.h - Implementation of the RVM opcodes - included
  from Python/ceval.c (reduces merge conflicts)

- reg-opcodes.h - Running list of opcodes which need still to be
  implemented


To Do
=====

Lots and lots.  Here are a few:

- Getting the various ``YIELD`` instructions working.  I stalled on
  the intimate relationship between Objects/genobject.c and the PyVM
  stack.

- Finish off the ``CALL_FUNCTION*`` opcodes.

- Async this-n-that.  I have zero experience with that, even as a
  Python programmer.

- Implementing some of the more complex language constructs mentioned
  above.  The challenge is that many of them require the successful
  implementation of a number of different opcodes before testing can
  reasonably be started.

- Test cases.  Lots and lots of test cases.  Someone without a lot of
  experience with Python's internals could tackle the creation of many
  of these.

- Refactor Lib/test/test_rattlesnake.py.  It should be broken into
  multiple modules.

- Optimization.  It's probably too early for much, but
  fixing/generalizing ``forward_propagate_fast_loads`` to correctly
  deal with implicit register reference would be huge.
  (``LOAD_FAST_REG`` and ``STORE_FAST_REG`` are conceptually the same
  opcode.)

- Opcode prediction and fast dispatch.  Currently, the register
  instruction implementations all end with normal calls to
  DISPATCH(). There is no use of the PREDICTED(), PREDICT() or
  FAST_DISPATCH() macros.  These can all be applied to the register
  VM.

- Generate RVM code from the AST instead of a PyVM-to-RVM translator.

- Paul Sokolovsky [#callingsokolovsky] pointed out that the calling
  convention for operations such as functions and list (and other
  containers) construction might best be changed.  Currently, the
  implementation preserves the existing calling conventions.

- Potentially extend instruction size from two bytes to four,
  dramatically reducing use of ``EXTENDED_ARG`` in the process at the
  expense of even larger code (maybe, but maybe not).


Implementing a New Opcode
=========================

A few steps are required to implement a new RVM opcode.

- Add a simple test case to ``Lib/test/test_rattlesnake.py``.

- Add a relevant ``def_op`` call to Lib/opcode.py.  Note that the PyVM
  instructions have all been compressed to the low end.  There are no
  more gaps.  Generally, you will want to add to the end so as not to
  disturb the opcode numbers for existing instructions.  Still, if it
  makes sense to add it in the middle, you'll just have a bit more
  work later (tedious, not life-threatening).  You might also need
  some auxiliary calls (e.g., ``hasregds``).  That's mostly for pretty
  display by ``dis``. You'll figure that out when you need it...

- Add a corresponding switch case to ``Python/ceval_reg.h``.

- Assuming you already have a working interpreter, run:

    make regen-all && make && ./python -E Lib/test/regrtest.py test_rattlesnake

Example
-------

Let's add the framework for a ``CALL_METHOD_REG`` opcode. First, the test case::

    def test_callmeth(self):
        class X:
            def meth1(self, a):
                return self.meth2(a)
            def meth2(self, a):
                return a
        x = X()
        (pyvm, rvm) = self.function_helper(x.meth1)
        self.assertEqual(pyvm(4), rvm(4))

Verify that calling x.meth1 exercises ``CALL_METHOD``::

    >>> dis.dis(X.meth1)
      4           0 LOAD_FAST                       0 (self)
                  2 LOAD_METHOD                     0 (meth2)
                  4 LOAD_FAST                       1 (a)
                  6 CALL_METHOD                     1
                  8 RETURN_VALUE
    >>> dis.dis(X.meth2)
      6           0 LOAD_FAST                       1 (a)
                  2 RETURN_VALUE

Whoops! It also exercises ``LOAD_METHOD``. We need to implement
``LOAD_METHOD_REG`` as well.

Add two ``def_op`` calls to the end of Lib/opcode.py::

    def_op('LOAD_METHOD_REG', op) ; op += 1
    def_op('CALL_METHOD_REG', op) ; op += 1

Extend the switch statement in ``Python/compile.c:stack_effect`` (this
enumeration of each ``*_REG`` instruction needs to change - I just
haven't gotten around to it)::

    case LOAD_METHOD_REG:
    case CALL_METHOD_REG:

Next, stub out the relevant cases in ``ceval_reg.h``::

    case TARGET(LOAD_METHOD_REG): {
        /* not yet implemented */
        goto error;
        DISPATCH();
    }

    case TARGET(CALL_METHOD_REG): {
        /* not yet implemented */
        goto error;
        DISPATCH();
    }

Run ``make regen-all``.  Chicken-and-egg means you will often have to
run it twice. Now run ``make``.  Finally, check to see that our test
case is exercised and fails::

    % ./python -E Lib/test/regrtest.py test_rattlesnake
    ...
    test test_rattlesnake failed -- Traceback (most recent call last):
      File "/home/skip/src/python/rvm/Lib/test/test_rattlesnake.py", line 75, in test_callmeth
        (pyvm, rvm) = self.function_helper(x.meth1)
      File "/home/skip/src/python/rvm/Lib/test/test_rattlesnake.py", line 544, in function_helper
        isc.gen_rvm()
      File "/home/skip/src/python/rvm/Lib/rattlesnake/converter.py", line 200, in gen_rvm
        pyvm.gen_rvm(rvm)
      File "/home/skip/src/python/rvm/Lib/rattlesnake/blocks.py", line 86, in gen_rvm
        convert = DISPATCH[pyvm_inst.opcode]
    KeyError: 119

This fails because we haven't implemented the relevant converters yet.
To get farther, we need to add the relevant functions in
``Lib/rattlesnake``, probably in ``function.py``.

Converters for each instruction consist of a function which mimics the
stack activity of the instruction being converted and a subclass of
Instruction which the function instantiates and returns.  Here's a
quick sketch for ``LOAD_METHOD`` (first cut - probably still needs
some tweaks)::

    def load_method(self, instr, block):
        oparg = instr.opargs[0] # All PyVM opcodes have a single oparg
        obj = self.top()
        return LoadMethodInstruction(opcode.opmap['LOAD_METHOD_REG'],
                                     block, dest=obj, name1=obj)
    DISPATCH[opcode.opmap['LOAD_METHOD']] = load_method

    class LoadMethodInstruction(Instruction):
        "LOAD_METHOD_REG."
        def __init__(self, op, block, **kwargs):
            self.populate(("dest", "name1"), kwargs)
            super().__init__(op, block, **kwargs)

        @property
        def opargs(self):
            return (self.dest, self.name1)

As noted in ``Python/ceval.c``, ``LOAD_METHOD`` and ``CALL_METHOD``
are a pair.  The former does some work to decide if the method is
bound or not, while the latter takes one of two different paths
depending on the outcome of that decision.  (This extra logic is
probably why I didn't tackle these at the same time as
``CALL_FUNCTION`` and friends. Also, the stack diagrams in the
comments look like they require more brain power to understand than
I'm generally equipped with...)  Note that the extra logic in the
``(LOAD|CALL)_METHOD`` instructions means more test cases will be
required.

Lather, rinse, repeat.


References
==========

.. [#asthylt] Merge ast-branch to head, Hylton
   (https://github.com/python/cpython/commit/3e0055f8c65c407e74ce476b8e2b1fb889723514)

.. [#callingsokolovsky] Discussion on Python-Ideas mailing list
   (https://mail.python.org/archives/list/python-ideas@python.org/message/VXJ6MEX5EXHXUNB45ODP4VT2KUDAYNTE/)

.. [#dynlemb] Reordering opcodes (PEP 203 Augmented Assignment), Lemburg
   (https://mail.python.org/pipermail/python-dev/2000-July/007609.html)

.. [#dynmont] Getting Rid of Data Movement Instructions, Montanaro
   (https://mail.python.org/pipermail/python-list/2001-August/070944.html)

.. [#instpage] Profiling CPython at Instagram, Page
   (https://instagram-engineering.com/profiling-cpython-at-instagram-89d4cbeeb898)

.. [#moar] MoarVM
   (https://moarvm.org/)

.. [#parrot] Parrot
   (http://www.parrot.org/)

.. [#peephett] Improve code generation Hettinger, et al
   (https://github.com/python/cpython/commit/f6f575ae6fc4b58f8735b6aebaa422d48bedcef4)

.. [#peepmont] A Peephole Optimizer for Python, Montanaro
   (https://web.archive.org/web/20010414044328/https://www.foretec.com/python/workshops/1998-11/proceedings/papers/montanaro/montanaro.html)

.. [#puffin] Puffin GitHub Repository
   (https://github.com/lucian1900/puffin)

.. [#pynie] Pynie Dev Team
   (https://launchpad.net/~pynie-dev)

.. [#raku] Raku Programming Language
   (https://raku.org/)

.. [#regmont] Register fork of CPython, Montanaro
   (https://github.com/smontanaro/cpython/tree/register)

.. [#regstin] My registervm fork (2012), Stinner
   (https://mail.python.org/archives/list/registervm@python.org/thread/X72OYMPH2HLTY4SIGVPKSTIRWL2XFY7G/)

.. [#pep-590] Vectorcall: a fast calling protocol for CPython
   (https://www.python.org/dev/peps/pep-0590/)

.. [#predpitr] Faster opcode dispatch on gcc, Pitrou
   (https://bugs.python.org/issue4753)

.. [#vmshowdown] Virtual Machine Showdown: Stack Versus Registers
   (https://www.usenix.org/legacy/events/vee05/full_papers/p153-yunhe.pdf)

.. [#winterbottom] The design of the Inferno virtual machine
   (http://www.vitanuova.com/inferno/papers/hotchips.pdf)

.. [#wordcode] ceval: use Wordcode, 16-bit bytecode, Remud
   (https://bugs.python.org/issue26647)


Appendix - Opcode Frequencies
=============================

Pyperformance 1.0.0 was run using Python 3.9.0a5+ compiled with
``-DDYNAMIC_EXECUTION_PROFILE=true``, capturing instruction counts for
each benchmark.  The results are displayed below:

.. table:: Opcode Frequencies
   :widths: 50 25 25
   :align: center

   +---------------------+--------------+--------------+
   |Instruction          |     Percent  |  Cumulative  |
   +---------------------+--------------+--------------+
   |LOAD_FAST            |      25.8%   |    25.75%    |
   +---------------------+--------------+--------------+
   |LOAD_CONST           |       9.9%   |    35.64%    |
   +---------------------+--------------+--------------+
   |STORE_FAST           |       7.7%   |    43.31%    |
   +---------------------+--------------+--------------+
   |LOAD_GLOBAL          |       5.5%   |    48.79%    |
   +---------------------+--------------+--------------+
   |CALL_FUNCTION        |       4.4%   |    53.16%    |
   +---------------------+--------------+--------------+
   |POP_JUMP_IF_FALSE    |       4.3%   |    57.47%    |
   +---------------------+--------------+--------------+
   |LOAD_ATTR            |       3.4%   |    60.91%    |
   +---------------------+--------------+--------------+
   |FOR_ITER             |       3.4%   |     64.34%   |
   +---------------------+--------------+--------------+
   |JUMP_ABSOLUTE        |        2.6%  |     66.97%   |
   +---------------------+--------------+--------------+
   |RETURN_VALUE         |        2.4%  |     69.37%   |
   +---------------------+--------------+--------------+
   |LOAD_METHOD          |        2.4%  |     71.76%   |
   +---------------------+--------------+--------------+
   |CALL_METHOD          |        2.4%  |     74.14%   |
   +---------------------+--------------+--------------+
   |EXTENDED_ARG         |        2.0%  |     76.16%   |
   +---------------------+--------------+--------------+
   |BINARY_SUBSCR        |        1.9%  |     78.02%   |
   +---------------------+--------------+--------------+
   |STORE_SUBSCR         |        1.8%  |     79.87%   |
   +---------------------+--------------+--------------+
   |POP_TOP              |        1.8%  |     81.64%   |
   +---------------------+--------------+--------------+
   |BINARY_ADD           |        1.5%  |     83.15%   |
   +---------------------+--------------+--------------+
   |IS_OP                |        1.3%  |     84.40%   |
   +---------------------+--------------+--------------+
   |LOAD_DEREF           |        1.1%  |     85.55%   |
   +---------------------+--------------+--------------+
   |COMPARE_OP           |        1.1%  |     86.68%   |
   +---------------------+--------------+--------------+
   |BINARY_MULTIPLY      |        1.0%  |     87.66%   |
   +---------------------+--------------+--------------+
   |STORE_ATTR           |        1.0%  |     88.62%   |
   +---------------------+--------------+--------------+
   |BINARY_MODULO        |        0.9%  |     89.51%   |
   +---------------------+--------------+--------------+
   |BINARY_TRUE_DIVIDE   |        0.9%  |     90.37%   |
   +---------------------+--------------+--------------+
   |POP_JUMP_IF_TRUE     |        0.8%  |     91.18%   |
   +---------------------+--------------+--------------+
   |UNPACK_SEQUENCE      |        0.8%  |     91.99%   |
   +---------------------+--------------+--------------+
   |CONTAINS_OP          |        0.7%  |     92.73%   |
   +---------------------+--------------+--------------+
   |JUMP_FORWARD         |        0.7%  |     93.43%   |
   +---------------------+--------------+--------------+
   |YIELD_FROM           |        0.6%  |     94.03%   |
   +---------------------+--------------+--------------+
   |SETUP_FINALLY        |        0.5%  |     94.57%   |
   +---------------------+--------------+--------------+
   |POP_BLOCK            |        0.5%  |     95.10%   |
   +---------------------+--------------+--------------+
   |BUILD_TUPLE          |        0.4%  |     95.51%   |
   +---------------------+--------------+--------------+
   |STORE_NAME           |        0.4%  |     95.92%   |
   +---------------------+--------------+--------------+
   |GET_ITER             |        0.3%  |     96.27%   |
   +---------------------+--------------+--------------+
   |MAKE_FUNCTION        |        0.3%  |     96.61%   |
   +---------------------+--------------+--------------+
   |BINARY_SUBTRACT      |        0.3%  |     96.92%   |
   +---------------------+--------------+--------------+
   |LOAD_NAME            |        0.3%  |     97.22%   |
   +---------------------+--------------+--------------+
   |DUP_TOP              |        0.3%  |     97.50%   |
   +---------------------+--------------+--------------+
   |LIST_APPEND          |        0.3%  |     97.75%   |
   +---------------------+--------------+--------------+
   |BUILD_LIST           |        0.2%  |     97.98%   |
   +---------------------+--------------+--------------+
   |YIELD_VALUE          |        0.2%  |     98.16%   |
   +---------------------+--------------+--------------+
   |JUMP_IF_FALSE_OR_POP |        0.2%  |     98.34%   |
   +---------------------+--------------+--------------+
   |BUILD_SLICE          |        0.1%  |     98.47%   |
   +---------------------+--------------+--------------+
   |BINARY_AND           |        0.1%  |     98.59%   |
   +---------------------+--------------+--------------+
   |CALL_FUNCTION_KW     |        0.1%  |     98.71%   |
   +---------------------+--------------+--------------+
   |INPLACE_ADD          |        0.1%  |     98.81%   |
   +---------------------+--------------+--------------+
   |LOAD_CLOSURE         |        0.1%  |     98.90%   |
   +---------------------+--------------+--------------+
   |ROT_TWO              |        0.1%  |     98.98%   |
   +---------------------+--------------+--------------+
   |BUILD_MAP            |        0.1%  |     99.06%   |
   +---------------------+--------------+--------------+
   |JUMP_IF_TRUE_OR_POP  |        0.1%  |     99.13%   |
   +---------------------+--------------+--------------+
   |JUMP_IF_NOT_EXC_MATCH|        0.1%  |     99.21%   |
   +---------------------+--------------+--------------+
   |SETUP_WITH           |        0.1%  |     99.27%   |
   +---------------------+--------------+--------------+
   |CALL_FUNCTION_EX     |        0.1%  |     99.34%   |
   +---------------------+--------------+--------------+
   |FORMAT_VALUE         |        0.1%  |     99.39%   |
   +---------------------+--------------+--------------+
   |POP_EXCEPT           |        0.0%  |     99.44%   |
   +---------------------+--------------+--------------+
   |STORE_DEREF          |        0.0%  |     99.49%   |
   +---------------------+--------------+--------------+
   |IMPORT_NAME          |        0.0%  |     99.53%   |
   +---------------------+--------------+--------------+
   |DELETE_SUBSCR        |        0.0%  |     99.56%   |
   +---------------------+--------------+--------------+
   |BUILD_STRING         |        0.0%  |     99.60%   |
   +---------------------+--------------+--------------+
   |DICT_MERGE           |        0.0%  |     99.63%   |
   +---------------------+--------------+--------------+
   |IMPORT_FROM          |        0.0%  |     99.67%   |
   +---------------------+--------------+--------------+
   |MAP_ADD              |        0.0%  |     99.70%   |
   +---------------------+--------------+--------------+
   |ROT_THREE            |        0.0%  |     99.73%   |
   +---------------------+--------------+--------------+
   |UNARY_NOT            |        0.0%  |     99.76%   |
   +---------------------+--------------+--------------+
   |RAISE_VARARGS        |        0.0%  |     99.78%   |
   +---------------------+--------------+--------------+
   |LIST_EXTEND          |        0.0%  |     99.81%   |
   +---------------------+--------------+--------------+
   |BUILD_CONST_KEY_MAP  |        0.0%  |     99.83%   |
   +---------------------+--------------+--------------+
   |LOAD_BUILD_CLASS     |        0.0%  |     99.85%   |
   +---------------------+--------------+--------------+
   |BINARY_OR            |        0.0%  |     99.87%   |
   +---------------------+--------------+--------------+
   |LIST_TO_TUPLE        |        0.0%  |     99.89%   |
   +---------------------+--------------+--------------+
   |INPLACE_SUBTRACT     |        0.0%  |     99.90%   |
   +---------------------+--------------+--------------+
   |BINARY_POWER         |        0.0%  |     99.92%   |
   +---------------------+--------------+--------------+
   |BINARY_FLOOR_DIVIDE  |        0.0%  |     99.93%   |
   +---------------------+--------------+--------------+
   |BUILD_SET            |        0.0%  |     99.94%   |
   +---------------------+--------------+--------------+
   |GET_YIELD_FROM_ITER  |        0.0%  |     99.95%   |
   +---------------------+--------------+--------------+
   |INPLACE_FLOOR_DIVIDE |        0.0%  |     99.96%   |
   +---------------------+--------------+--------------+
   |UNARY_INVERT         |        0.0%  |     99.97%   |
   +---------------------+--------------+--------------+
   |INPLACE_OR           |        0.0%  |     99.98%   |
   +---------------------+--------------+--------------+
   |DELETE_NAME          |        0.0%  |     99.98%   |
   +---------------------+--------------+--------------+
   |DELETE_ATTR          |        0.0%  |     99.98%   |
   +---------------------+--------------+--------------+
   |UNARY_NEGATIVE       |        0.0%  |     99.99%   |
   +---------------------+--------------+--------------+
   |STORE_GLOBAL         |        0.0%  |     99.99%   |
   +---------------------+--------------+--------------+
   |INPLACE_RSHIFT       |        0.0%  |     99.99%   |
   +---------------------+--------------+--------------+
   |SET_ADD              |        0.0%  |     99.99%   |
   +---------------------+--------------+--------------+
   |BINARY_XOR           |        0.0%  |     99.99%   |
   +---------------------+--------------+--------------+
   |ROT_FOUR             |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |IMPORT_STAR          |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |BINARY_LSHIFT        |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |RERAISE              |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |WITH_EXCEPT_START    |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |INPLACE_AND          |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |INPLACE_MODULO       |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |BINARY_RSHIFT        |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |INPLACE_MULTIPLY     |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |DELETE_FAST          |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |INPLACE_LSHIFT       |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |SET_UPDATE           |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |DUP_TOP_TWO          |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |LOAD_CLASSDEREF      |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |DICT_UPDATE          |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
   Local Variables:
   mode: rst
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
