PEP: 9999
Title: Register Virtual Machine for Python
Author: Skip Montanaro <skip@python.org>
Status: Active
Type: Standards Track
Content-Type: text/x-rst
Created: 18-Mar-2021
Python-Version: 4.0
Post-History: dd-mmm-yyyy

.. Process with rstpep2html to get table of contents and preserve
   above header.

Abstract
========

This PEP proposes the addition of register-based instructions to the
existing Python virtual machine, with the intent that they eventually
replace the existing stack-based opcodes.  Though both sets of
instructions are active in this effort, that is largely to make
initial testing easier.  They are almost completely distinct.  Within
a single function only one set of opcodes or the other will be used at
any one time.  (A few instructions are used by both.)  Considering
that, the current stack-based opcodes are referred to below as the
Python Virtual Machine ("PyVM") and the new register-based opcodes are
referred to as the Register Virtual Machine ("RVM").

Though submitted as a standards track PEP, the approach taken in the
initial implementation requires PyVM to be active as RVM is developed.
For that reason, as of its initial writing this document serves as
much as a guide for the architecture changes and for work which must
be done as for a rationale for the new virtual machine.


Motivation
==========

Over the past two decades, Python's virtual machine has been improved
in many ways.  Among the most visible to the core Python developer
are:

- Peephole optimizations [#peephett]_

- Function call performance improvements [#pep-590]_

- Use of computed gotos and opcode prediction [#predpitr]_

- Introduction of many new instructions (reference?)

- Wordcode [#wordcode]_

Despite all that effort, opcodes which do nothing more than move data
onto or off of the stack (``LOAD_FAST``, ``LOAD_GLOBAL``, etc) still
account for nearly half of all opcodes executed.  This has been
consistently true over a long period of time [#dynlemb]_, [#instpage]_
and remains true today.  Running Pyperformance using a development
version of Python 3.9 showed that the five most frequently executed
pure stack opcodes (``LOAD_FAST``, ``STORE_FAST``, ``POP_TOP``,
``DUP_TOP`` and ``ROT_TWO``) accounted for 35% of all executed
instructions.  They are low-cost instructions (compared with
``CALL_FUNCTION`` for example), but still eat up time and space in the
virtual machine, making it less efficient than it might be.  (The
complete table of opcode frequencies is in `Appendix - Opcode
Frequencies`_.)

Consider the layout of the data section of a Frame object::

    +----------------+-----------------+------------+
    |                |                 |            |
    | fastlocals     | cells + frees   | stack      |
    +----------------+-----------------+------------+
    ^                ^                 ^
    |                |                 |
    +-- f_localsplus +-- f_cellvars    +-- f_valuestack

All those ``LOAD_FAST`` and ``STORE_FAST`` instructions just copy
pointers between chunks of RAM which are just a few bytes away from
each other in memory.  It seems reasonable to consider a different
layout where ``fastlocals`` and the ``stack`` (reimagined as temporary
registers) are adjacent and, taken together, could be reimagined as an
addressable register file::

    +---------------------------+----------------+
    |                           |                |
    | fastlocals + registers    | cells + frees  |
    +---------------------------+----------------+
    ^                           ^
    |                           |
    +-- f_localsplus            +-- f_cellvars

While swapping out the virtual machine in toto doesn't qualify as "low
hanging fruit," even after all this time it seems like it might
worthwhile to investigate such a change.


Previous Work
=============

Between 1998 and 2001, the author began work on a system named
Rattlesnake based on Python 1.5.2.  It was never more than a barebones
proof-of-concept, but did implement over 50 register-oriented
instructions, a substantial fraction of the machine at that time.  Its
structure was based on an earlier peephole optimizer written by the
author [#peepmont]_ and implemented as a peephole optimization class
which could be chained together with other optimizations.  As such, it
worked from the existing PyVM instructions, not any higher-level
representation.  While it never saw the light of day, the code
followed the author of this document around from one computer to
another (somehow never getting lost) and remained a subtle reminder of
the possibility it represented.  It lives on, providing much of the
initial starting framework for the current translator.

In 2012, Victor Stinner implemented a nearly complete system
[#regstin].  It failed for a number of reasons, but it demonstrated a
significant performance improvement and was very close to a complete
system.

Both systems worked from PyVM bytecode as the starting point, and both
were based on the old bytecode instruction format which used variable
length instructions.  In 2005, Jeremy Hylton merged a new AST-based
compiler to the master development branch [#asthylt]_.


Rationale
=========

The "correct" approach is to modify, replace or duplicate the existing
AST-based compiler to produce RVM instructions.  Alas, the author had
no experience with it and decided to fall back to translation of PyVM
to RVM.  That provides fewer optimization opportunities, but allows
all the translation to be done using an external Python program.  It
should provide enough data to decide if the general idea is workable.
Aside from allowing quicker experimentation, it also makes the
development more accessible to Python developers without much
experience with the CPython implementation.  If the approach proves
worthwhile, developers with more experience in the current Python
internals can push that part of the system forward.  Consider the
current approach an attempt at producing a "minimum viable product,"
to use a business buzz phrase.

Obviously, some work in the C code base is required.  This is mostly
confined to two files:

- ``Python/ceval.c`` - Each new instruction must be implemented, but
  Python/ceval.c provides an excellent set of templates in the form of
  the current PyVM instructions.  For the most part, the semantics of
  an RVM instruction are the same as the corresponding PyVM
  instruction.  The main difference between pairs of related
  instructions is how they fetch their data and store their results.

- ``Objects/frameobject.c`` - Most of this work has been done already,
  but more could be done.  The primary work necessary was
  reorganization of the ``f_localsplus`` array so local variables and
  the PyVM stack space were adjacent.  As Stinner noted though
  [#regstin]_, adding a copy of the code object's constants to the
  frame object is also a performance win.  This is suggested by the
  opcode frequencies table.  ``LOAD_CONST`` is the second most
  frequently executed instruction.


Reference Counts
----------------

While the same memory is used for the stack (PyVM) and registers
(RVM), their semantics are different.  When used as a stack, that
memory is completely transparent to reference counts.  As objects are
pushed on and popped from the stack, the responsibility of maintaining
reference counts lies with the individual instructions.  At the end of
normal function execution, the stack will have dwindled away to
nothing, meaning no reference counts need to be decremented.

Such is not the case when that memory is used for registers.  At the
end of function execution, any number of them might still be active
and require decrement of their reference counts.  In the current
implementation, this happens at the end of
``_PyEval_EvalFrameDefault``.  Since the pattern of use of the
register space can differ from one call of a function to the next and
frame objects are reused where possible, the registers are cleared,
not just decref'd.


Object Lifetime
'''''''''''''''

Closely related to reference counts is the notion of object lifetime.
When an object's reference count drops to zero, CPython's semantics
mean it will be reclaimed immediately.  What happens if an object is
created and completely used early during the execution of a
long-running function but its reference count doesn't drop to zero
until the end of the function?  Consider this (silly) function::

    def long_running():
        x = [1] * int(10e7)
        y = [2] * int(10e7)
        z = (x + y) * 3
        # Could reclaim x and y here
        char = z[99]
        # Could reclaim z here
        result = do_something_long_running(char)
        return result

Currently, RVM clears registers at the end of frame execution.
Instead, registers should be cleared upon last reference.  All three
large lists currently stick around until function return, but are
unused after extracting the single character which is used.  For that
length of time, a large amount of memory is consumed unnecessarily.
The comments above indicate where registers holding x, y and z should
be cleared.  Victor Stinner's implementation [#regstin] does this
correctly.


Backwards Compatibility
=======================

Since the instruction set is an internal implementation detail
(although a significant one), there should be few backward
compatibility issues.  (Note the object lifetime discussion above,
however.) Tools which manipulate bytecode will obviously have to be
modified.  The ``dis`` module has been modified as necessary and will
probably undergo further changes.


Reference Implementation
========================

An in-progress (not yet complete) implementation [#regmont]_ is
available as a fork of the current CPython GitHub repo.  As of this
writing (March 2021) it remains quite incomplete, implementing just 57
register instructions compared with the 120+ PyVM instructions. (Note
though that some PyVM instructions should disappear, including stack
rotation instructions and --- with optimizations --- many register
loads and stores.


Current Status
--------------

As of March 18, 2021:

- Implemented more than 50 instructions (the easy ones <wink>) - all
  ``BINARY``, ``INPLACE`` and , ``UNARY`` instructions,
  ``RETURN_VALUE_REG``, most ``LOAD`` instructions, several ``STORE``
  instructions, ``COMPARE_OP_REG``, ``JUMP_IF_(TRUE|FALSE)_REG``, some
  ``CALL_FUNCTION`` instructions, most container-related ``BUILD``
  instructions, ``LIST_EXTEND_REG``, some loop and iteration
  instructions and dictionary merge/update. Simple test cases exist
  for most of these, though the most recently added instructions
  probably still lack suitable test cases. (When the 'make test'
  target completes, it identifies implemented instructions which
  weren't executed on the run.)

- Implemented translator parts

  - Identification of basic blocks

  - Mapping between the PyVM and RVM versions of the above
    instructions (much leftover from Rattlesnake, but not yet tested)

  - Elimination of ``LOAD_FAST_REG`` and ``STORE_FAST_REG`` by forward
    propagation of the former. Implementation of backward propagation
    to eliminate the latter was broken, so is currently disabled.
    There is still work to do here, but it represents a good place for
    optimization.  Note

  - Generation of wordcode from the RVM blocks.

  - Based on current testing, using -R with ``Tools/scripts/run_tests.py``,
    reference counting seems to work.


Implementing More Instructions
''''''''''''''''''''''''''''''

Initially, most instructions could be revealed in isolation with a
simple function, making it fairly easy to implement and test the
translations.  Plenty of instructions remain which can be implemented
in isolation, most of which should have straightforward
implementations.  For example (not exhaustive)::

    BUILD_SLICE
    BUILD_STRING
    CALL_METHOD
    DELETE_GLOBAL
    DELETE_SUBSCR
    FORMAT_VALUE
    IMPORT_FROM
    LOAD_DEREF
    LOAD_METHOD
    STORE_SUBSCR
    YIELD_VALUE

Some instructions (``DUP_TOP``, ``ROT`` instructions, ``POP_TOP``,
etc) may not require translation at all, and just require a little bit
of extra bookkeeping during translation.

Still, as more complex control flow constructs are tackled, larger
groups of not-as-yet-translated instructions must be implemented.  It
would be worthwhile to try and translate as many of the necessary
instructions in more-or-less isolation to reduce the number of
translations which must be implemented correctly before any testing
can proceed.  Here are some example functions and the instructions
they use which have not yet been translated.

This function::

    def f(a):
      try:
        return 17.1 / a
      except ZeroDivisionError:
        print("a is zero!")
        raise

requires::

    DUP_TOP
    JUMP_IF_NOT_EXC_MATCH
    POP_BLOCK
    POP_EXCEPT
    POP_TOP
    RAISE_VARARGS
    RERAISE
    SETUP_FINALLY

This function::

    def f(a):
      for i in range(a):
        yield i

requires::

    POP_TOP
    YIELD_VALUE

Async functions are especially complex.  This function::

    async def f():
        print('hello')
        await asyncio.sleep(1)
        print('world')

requires::

    CALL_METHOD
    GET_AWAITABLE
    LOAD_METHOD
    POP_TOP
    YIELD_FROM

This function::

    async def f(a):
      async for i in range(a):
        pass

requires::

    GET_AITER
    SETUP_FINALLY
    GET_ANEXT
    YIELD_FROM
    POP_BLOCK
    END_ASYNC_FOR

This function::

    async def f(fn):
      async with open(fn) as fp:
        return fp.read(1)

requires::

    BEFORE_ASYNC_WITH
    CALL_METHOD
    DUP_TOP
    GET_AWAITABLE
    LOAD_METHOD
    POP_BLOCK
    POP_EXCEPT
    POP_TOP
    RERAISE
    ROT_TWO
    SETUP_ASYNC_WITH
    WITH_EXCEPT_START
    YIELD_FROM

This function::

    def f(fn):
      with open(fn) as fp:
        print(fp.read(1))

requires::

    CALL_METHOD
    DUP_TOP
    POP_BLOCK
    POP_EXCEPT
    POP_TOP
    RERAISE
    SETUP_WITH
    WITH_EXCEPT_START

To simplify implementation of these more complex translations, picking
off as many of the unimplemented simpler translations first would be
worthwhile.


Rejected Ideas
==============

No ideas have truly been rejected at this point.  The author has
simply been following the path of least resistance.  That means
implementing bits in Python where possible and disturbing the rest of
the CPython implementation as little as possible.  Those are just
trade-offs necessary to move things forward.  They aren't cast in
stone.


Open Issues
===========

A large number of issues remain unresolved.  See the `issue
tracker <https://github.com/smontanaro/cpython/issues>`_ for a number
of open issues not included here.

- This proto-PEP - It is still quite incomplete, and really hasn't
  been tracking the implementation very well in the past several
  months.

- Wordcode - To simplify the work, wordcode was retained.  This works,
  but relies heavily on the ``EXTENDED_ARG`` instruction to provide
  arguments to instructions which need more than one.  At the moment,
  ``COMPARE_OP_REG`` is the argument champion, requiring four args.
  While ``EXTENDED_ARG`` is really only half an instruction, most RVM
  instructions implemented so far must be prefixed by at least one of
  them.  It would be worth considering if a 32-bit instruction size
  for RVM makes more sense, both as a performance improvement and to
  reduce the size of the generated code.  (medium)

- Implement opcode prediction/fast dispatch.  Without that, you can't
  make apples-to-apples performance comparisons.  (easy?)

- Translation of larger compilation units than functions (classes,
  modules and packages) with output to a bytecode file (perhaps with
  ".pyr" extension).  (medium?)

- Refactor InstructionSetConverter - This still contains remnants of
  the original peephole optimizer.  The base class is likely no longer
  required, and ISC itself could probably be split into multiple mixin
  classes.  (easy)

- Rework dis module or instruction names - Tacking on ``_REG`` to a
  bunch of instructions threw off the dis module's (fragile) output
  formatting.  Increasing ``dis._OPNAME_WIDTH`` from 20 to 23 and
  reformatting **every expected output string** in ``test_dis.py``
  helped for awhile until even longer instruction names arrived.  All
  that reformatting was tedious.  Fixing ``dis`` to be more resilient
  might be a better way to go.

  OTOH, maybe RVM opcode names should look more like traditional
  assembler instructions.  (The author is getting on in years and
  finds something which looks more like assembler attractive, given
  his initial experience programming computers in the dark ages.)
  Instead of ``BINARY_ADD_REG``, you might call it ``BAR``.  Simply
  constructing opcode names by joining the first letters of each word
  won't work though (collisions - ``BINARY_ADD_REG`` and
  ``BINARY_AND_REG`` would both map to ``BAR``), so you'd have to
  implement a scheme which overrides in specific instances (``BAR``
  and ``BANDR``, for example).  (easy?)

- Matrix multiplication is so far untested, mostly because I can't
  handle classes yet.


Files
=====

These are the big changes.

- Lib/rattlesnake - The Python implementation of the translator

- Lib/opcode.py - Enumeration of the implemented opcodes

- Python/ceval_reg.h - Implementation of the RVM opcodes - included
  from Python/ceval.c (reduces merge conflicts)

- reg-opcodes.h - Running list of opcodes which need still to be
  implemented


To Do
=====

Lots and lots.  Here are a few:

- Getting the various ``YIELD`` instructions working.  I stalled on
  the intimate relationship between Objects/genobject.c and the PyVM
  stack.

- Finish off the ``CALL_FUNCTION*`` opcodes.

- Async this-n-that.  I have zero experience with that, even as a
  Python programmer.

- Implementing some of the more complex language constructs mentioned
  above.  The challenge is that many of them require the successful
  implementation of a number of different opcodes before testing can
  reasonably be started.

- Test cases.  Lots and lots of test cases.  Someone without a lot of
  experience with Python's internals could tackle the creation of many
  of these.

- Refactor Lib/test/test_rattlesnake.py.  It should be broken into
  multiple modules.

- Optimization.  It's probably too early for much, but
  fixing/generalizing ``forward_propagate_fast_loads`` to correctly
  deal with implicit register reference would be huge.
  (``LOAD_FAST_REG`` and ``STORE_FAST_REG`` are conceptually the same
  opcode.)

- Generate RVM code from the AST instead of a PyVM-to-RVM translator.


Implementing a New Opcode
=========================

A few steps are required to implement a new RVM opcode.

- Add a simple test case to ``Lib/test/test_rattlesnake.py``.

- Add a relevant ``def_op`` call to Lib/opcode.py.  Note that the PyVM
  instructions have all been compressed to the low end.  There are no
  more gaps.  Generally, you will want to add to the end so as not to
  disturb the opcode numbers for existing instructions.  Still, if it
  makes sense to add it in the middle, you'll just have a bit more
  work later (tedious, not life-threatening).  You might also need
  some auxiliary calls (e.g., ``hasregds``).  That's mostly for pretty
  display by ``dis``. You'll figure that out when you need it...

- Add a corresponding switch case to ``Python/ceval_reg.h``.

- Assuming you already have a working interpreter, run:

    make regen-all && make && ./python -E Lib/test/regrtest.py test_rattlesnake

Example
-------

Let's add the framework for a ``CALL_METHOD_REG`` opcode. First, the test case::

    def test_callmeth(self):
        class X:
            def meth1(self, a):
                return self.meth2(a)
            def meth2(self, a):
                return a
        x = X()
        (pyvm, rvm) = self.function_helper(x.meth1)
        self.assertEqual(pyvm(4), rvm(4))

Verify that calling x.meth1 exercises ``CALL_METHOD``::

    >>> dis.dis(X.meth1)
      4           0 LOAD_FAST                       0 (self)
                  2 LOAD_METHOD                     0 (meth2)
                  4 LOAD_FAST                       1 (a)
                  6 CALL_METHOD                     1
                  8 RETURN_VALUE
    >>> dis.dis(X.meth2)
      6           0 LOAD_FAST                       1 (a)
                  2 RETURN_VALUE

Whoops! It also exercises ``LOAD_METHOD``. We need to implement
``LOAD_METHOD_REG`` as well.

Add two ``def_op`` calls to the end of Lib/opcode.py::

    def_op('LOAD_METHOD_REG', op) ; op += 1
    def_op('CALL_METHOD_REG', op) ; op += 1

Extend the switch statement in ``Python/compile.c:stack_effect`` (this
enumeration of each ``*_REG`` instruction needs to change - I just
haven't gotten around to it)::

    case LOAD_METHOD_REG:
    case CALL_METHOD_REG:

Next, stub out the relevant cases in ``ceval_reg.h``::

    case TARGET(LOAD_METHOD_REG): {
        /* not yet implemented */
        goto error;
        DISPATCH();
    }

    case TARGET(CALL_METHOD_REG): {
        /* not yet implemented */
        goto error;
        DISPATCH();
    }

Run ``make regen-all``.  Chicken-and-egg means you will often have to
run it twice. Now run ``make``.  Finally, check to see that our test
case is exercised and fails::

    % ./python -E Lib/test/regrtest.py test_rattlesnake
    ...
    test test_rattlesnake failed -- Traceback (most recent call last):
      File "/home/skip/src/python/rvm/Lib/test/test_rattlesnake.py", line 75, in test_callmeth
        (pyvm, rvm) = self.function_helper(x.meth1)
      File "/home/skip/src/python/rvm/Lib/test/test_rattlesnake.py", line 544, in function_helper
        isc.gen_rvm()
      File "/home/skip/src/python/rvm/Lib/rattlesnake/converter.py", line 200, in gen_rvm
        pyvm.gen_rvm(rvm)
      File "/home/skip/src/python/rvm/Lib/rattlesnake/blocks.py", line 86, in gen_rvm
        convert = DISPATCH[pyvm_inst.opcode]
    KeyError: 119

This fails because we haven't implemented the relevant converters yet.
To get farther, we need to add the relevant functions in
``Lib/rattlesnake``, probably in ``function.py``.

Converters for each instruction consist of a function which mimics the
stack activity of the instruction being converted and a subclass of
Instruction which the function instantiates and returns.  Here's a
quick sketch for ``LOAD_METHOD`` (first cut - probably still needs
some tweaks)::

    def load_method(self, instr, block):
        oparg = instr.opargs[0] # All PyVM opcodes have a single oparg
        obj = self.top()
        return LoadMethodInstruction(opcode.opmap['LOAD_METHOD_REG'],
                                     block, dest=obj, name1=obj)
    DISPATCH[opcode.opmap['LOAD_METHOD']] = load_method

    class LoadMethodInstruction(Instruction):
        "LOAD_METHOD_REG."
        def __init__(self, op, block, **kwargs):
            self.populate(("dest", "name1"), kwargs)
            super().__init__(op, block, **kwargs)

        @property
        def opargs(self):
            return (self.dest, self.name1)

As noted in ``Python/ceval.c``, ``LOAD_METHOD`` and ``CALL_METHOD``
are a pair.  The former does some work to decide if the method is
bound or not, while the latter takes one of two different paths
depending on the outcome of that decision.  (This extra logic is
probably why I didn't tackle these at the same time as
``CALL_FUNCTION`` and friends. Also, the stack diagrams in the
comments look like they require more brain power to understand than
I'm generally equipped with...)  Note that the extra logic in the
``(LOAD|CALL)_METHOD`` instructions means more test cases will be
required.

Lather, rinse, repeat.


References
==========

.. [#asthylt] Merge ast-branch to head, Hylton
   (https://github.com/python/cpython/commit/3e0055f8c65c407e74ce476b8e2b1fb889723514)

.. [#dynlemb] Reordering opcodes (PEP 203 Augmented Assignment), Lemburg
   (https://mail.python.org/pipermail/python-dev/2000-July/007609.html)

.. [#dynmont] Getting Rid of Data Movement Instructions, Montanaro
   (https://mail.python.org/pipermail/python-list/2001-August/070944.html)

.. [#instpage] Profiling CPython at Instagram, Page
   (https://instagram-engineering.com/profiling-cpython-at-instagram-89d4cbeeb898)

.. [#peephett] Improve code generation Hettinger, et al
   (https://github.com/python/cpython/commit/f6f575ae6fc4b58f8735b6aebaa422d48bedcef4)

.. [#peepmont] A Peephole Optimizer for Python, Montanaro
   (https://web.archive.org/web/20010414044328/https://www.foretec.com/python/workshops/1998-11/proceedings/papers/montanaro/montanaro.html)

.. [#regmont] Register fork of CPython, Montanaro
   (https://github.com/smontanaro/cpython/tree/register)

.. [#regstin] My registervm fork (2012), Stinner
   (https://mail.python.org/archives/list/registervm@python.org/thread/X72OYMPH2HLTY4SIGVPKSTIRWL2XFY7G/)

.. [#pep-590] Vectorcall: a fast calling protocol for CPython
   (https://www.python.org/dev/peps/pep-0590/)

.. [#predpitr] Faster opcode dispatch on gcc, Pitrou
   (https://bugs.python.org/issue4753)

.. [#wordcode] ceval: use Wordcode, 16-bit bytecode, Remud
   (https://bugs.python.org/issue26647)


Appendix - Opcode Frequencies
=============================

Pyperformance 1.0.0 was run using Python 3.9.0a5+ compiled with
``-DDYNAMIC_EXECUTION_PROFILE=true``, capturing instruction counts for
each benchmark.  The results are displayed below:

.. table:: Opcode Frequencies
   :widths: 50 25 25
   :align: center

   +---------------------+--------------+--------------+
   |Instruction          |     Percent  |  Cumulative  |
   +---------------------+--------------+--------------+
   |LOAD_FAST            |      25.8%   |    25.75%    |
   +---------------------+--------------+--------------+
   |LOAD_CONST           |       9.9%   |    35.64%    |
   +---------------------+--------------+--------------+
   |STORE_FAST           |       7.7%   |    43.31%    |
   +---------------------+--------------+--------------+
   |LOAD_GLOBAL          |       5.5%   |    48.79%    |
   +---------------------+--------------+--------------+
   |CALL_FUNCTION        |       4.4%   |    53.16%    |
   +---------------------+--------------+--------------+
   |POP_JUMP_IF_FALSE    |       4.3%   |    57.47%    |
   +---------------------+--------------+--------------+
   |LOAD_ATTR            |       3.4%   |    60.91%    |
   +---------------------+--------------+--------------+
   |FOR_ITER             |       3.4%   |     64.34%   |
   +---------------------+--------------+--------------+
   |JUMP_ABSOLUTE        |        2.6%  |     66.97%   |
   +---------------------+--------------+--------------+
   |RETURN_VALUE         |        2.4%  |     69.37%   |
   +---------------------+--------------+--------------+
   |LOAD_METHOD          |        2.4%  |     71.76%   |
   +---------------------+--------------+--------------+
   |CALL_METHOD          |        2.4%  |     74.14%   |
   +---------------------+--------------+--------------+
   |EXTENDED_ARG         |        2.0%  |     76.16%   |
   +---------------------+--------------+--------------+
   |BINARY_SUBSCR        |        1.9%  |     78.02%   |
   +---------------------+--------------+--------------+
   |STORE_SUBSCR         |        1.8%  |     79.87%   |
   +---------------------+--------------+--------------+
   |POP_TOP              |        1.8%  |     81.64%   |
   +---------------------+--------------+--------------+
   |BINARY_ADD           |        1.5%  |     83.15%   |
   +---------------------+--------------+--------------+
   |IS_OP                |        1.3%  |     84.40%   |
   +---------------------+--------------+--------------+
   |LOAD_DEREF           |        1.1%  |     85.55%   |
   +---------------------+--------------+--------------+
   |COMPARE_OP           |        1.1%  |     86.68%   |
   +---------------------+--------------+--------------+
   |BINARY_MULTIPLY      |        1.0%  |     87.66%   |
   +---------------------+--------------+--------------+
   |STORE_ATTR           |        1.0%  |     88.62%   |
   +---------------------+--------------+--------------+
   |BINARY_MODULO        |        0.9%  |     89.51%   |
   +---------------------+--------------+--------------+
   |BINARY_TRUE_DIVIDE   |        0.9%  |     90.37%   |
   +---------------------+--------------+--------------+
   |POP_JUMP_IF_TRUE     |        0.8%  |     91.18%   |
   +---------------------+--------------+--------------+
   |UNPACK_SEQUENCE      |        0.8%  |     91.99%   |
   +---------------------+--------------+--------------+
   |CONTAINS_OP          |        0.7%  |     92.73%   |
   +---------------------+--------------+--------------+
   |JUMP_FORWARD         |        0.7%  |     93.43%   |
   +---------------------+--------------+--------------+
   |YIELD_FROM           |        0.6%  |     94.03%   |
   +---------------------+--------------+--------------+
   |SETUP_FINALLY        |        0.5%  |     94.57%   |
   +---------------------+--------------+--------------+
   |POP_BLOCK            |        0.5%  |     95.10%   |
   +---------------------+--------------+--------------+
   |BUILD_TUPLE          |        0.4%  |     95.51%   |
   +---------------------+--------------+--------------+
   |STORE_NAME           |        0.4%  |     95.92%   |
   +---------------------+--------------+--------------+
   |GET_ITER             |        0.3%  |     96.27%   |
   +---------------------+--------------+--------------+
   |MAKE_FUNCTION        |        0.3%  |     96.61%   |
   +---------------------+--------------+--------------+
   |BINARY_SUBTRACT      |        0.3%  |     96.92%   |
   +---------------------+--------------+--------------+
   |LOAD_NAME            |        0.3%  |     97.22%   |
   +---------------------+--------------+--------------+
   |DUP_TOP              |        0.3%  |     97.50%   |
   +---------------------+--------------+--------------+
   |LIST_APPEND          |        0.3%  |     97.75%   |
   +---------------------+--------------+--------------+
   |BUILD_LIST           |        0.2%  |     97.98%   |
   +---------------------+--------------+--------------+
   |YIELD_VALUE          |        0.2%  |     98.16%   |
   +---------------------+--------------+--------------+
   |JUMP_IF_FALSE_OR_POP |        0.2%  |     98.34%   |
   +---------------------+--------------+--------------+
   |BUILD_SLICE          |        0.1%  |     98.47%   |
   +---------------------+--------------+--------------+
   |BINARY_AND           |        0.1%  |     98.59%   |
   +---------------------+--------------+--------------+
   |CALL_FUNCTION_KW     |        0.1%  |     98.71%   |
   +---------------------+--------------+--------------+
   |INPLACE_ADD          |        0.1%  |     98.81%   |
   +---------------------+--------------+--------------+
   |LOAD_CLOSURE         |        0.1%  |     98.90%   |
   +---------------------+--------------+--------------+
   |ROT_TWO              |        0.1%  |     98.98%   |
   +---------------------+--------------+--------------+
   |BUILD_MAP            |        0.1%  |     99.06%   |
   +---------------------+--------------+--------------+
   |JUMP_IF_TRUE_OR_POP  |        0.1%  |     99.13%   |
   +---------------------+--------------+--------------+
   |JUMP_IF_NOT_EXC_MATCH|        0.1%  |     99.21%   |
   +---------------------+--------------+--------------+
   |SETUP_WITH           |        0.1%  |     99.27%   |
   +---------------------+--------------+--------------+
   |CALL_FUNCTION_EX     |        0.1%  |     99.34%   |
   +---------------------+--------------+--------------+
   |FORMAT_VALUE         |        0.1%  |     99.39%   |
   +---------------------+--------------+--------------+
   |POP_EXCEPT           |        0.0%  |     99.44%   |
   +---------------------+--------------+--------------+
   |STORE_DEREF          |        0.0%  |     99.49%   |
   +---------------------+--------------+--------------+
   |IMPORT_NAME          |        0.0%  |     99.53%   |
   +---------------------+--------------+--------------+
   |DELETE_SUBSCR        |        0.0%  |     99.56%   |
   +---------------------+--------------+--------------+
   |BUILD_STRING         |        0.0%  |     99.60%   |
   +---------------------+--------------+--------------+
   |DICT_MERGE           |        0.0%  |     99.63%   |
   +---------------------+--------------+--------------+
   |IMPORT_FROM          |        0.0%  |     99.67%   |
   +---------------------+--------------+--------------+
   |MAP_ADD              |        0.0%  |     99.70%   |
   +---------------------+--------------+--------------+
   |ROT_THREE            |        0.0%  |     99.73%   |
   +---------------------+--------------+--------------+
   |UNARY_NOT            |        0.0%  |     99.76%   |
   +---------------------+--------------+--------------+
   |RAISE_VARARGS        |        0.0%  |     99.78%   |
   +---------------------+--------------+--------------+
   |LIST_EXTEND          |        0.0%  |     99.81%   |
   +---------------------+--------------+--------------+
   |BUILD_CONST_KEY_MAP  |        0.0%  |     99.83%   |
   +---------------------+--------------+--------------+
   |LOAD_BUILD_CLASS     |        0.0%  |     99.85%   |
   +---------------------+--------------+--------------+
   |BINARY_OR            |        0.0%  |     99.87%   |
   +---------------------+--------------+--------------+
   |LIST_TO_TUPLE        |        0.0%  |     99.89%   |
   +---------------------+--------------+--------------+
   |INPLACE_SUBTRACT     |        0.0%  |     99.90%   |
   +---------------------+--------------+--------------+
   |BINARY_POWER         |        0.0%  |     99.92%   |
   +---------------------+--------------+--------------+
   |BINARY_FLOOR_DIVIDE  |        0.0%  |     99.93%   |
   +---------------------+--------------+--------------+
   |BUILD_SET            |        0.0%  |     99.94%   |
   +---------------------+--------------+--------------+
   |GET_YIELD_FROM_ITER  |        0.0%  |     99.95%   |
   +---------------------+--------------+--------------+
   |INPLACE_FLOOR_DIVIDE |        0.0%  |     99.96%   |
   +---------------------+--------------+--------------+
   |UNARY_INVERT         |        0.0%  |     99.97%   |
   +---------------------+--------------+--------------+
   |INPLACE_OR           |        0.0%  |     99.98%   |
   +---------------------+--------------+--------------+
   |DELETE_NAME          |        0.0%  |     99.98%   |
   +---------------------+--------------+--------------+
   |DELETE_ATTR          |        0.0%  |     99.98%   |
   +---------------------+--------------+--------------+
   |UNARY_NEGATIVE       |        0.0%  |     99.99%   |
   +---------------------+--------------+--------------+
   |STORE_GLOBAL         |        0.0%  |     99.99%   |
   +---------------------+--------------+--------------+
   |INPLACE_RSHIFT       |        0.0%  |     99.99%   |
   +---------------------+--------------+--------------+
   |SET_ADD              |        0.0%  |     99.99%   |
   +---------------------+--------------+--------------+
   |BINARY_XOR           |        0.0%  |     99.99%   |
   +---------------------+--------------+--------------+
   |ROT_FOUR             |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |IMPORT_STAR          |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |BINARY_LSHIFT        |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |RERAISE              |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |WITH_EXCEPT_START    |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |INPLACE_AND          |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |INPLACE_MODULO       |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |BINARY_RSHIFT        |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |INPLACE_MULTIPLY     |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |DELETE_FAST          |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |INPLACE_LSHIFT       |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |SET_UPDATE           |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |DUP_TOP_TWO          |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |LOAD_CLASSDEREF      |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+
   |DICT_UPDATE          |        0.0%  |    100.00%   |
   +---------------------+--------------+--------------+


Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
